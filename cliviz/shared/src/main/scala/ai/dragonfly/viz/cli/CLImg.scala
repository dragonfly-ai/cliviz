/*
 * Copyright 2023 dragonfly.ai
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ai.dragonfly.viz.cli

import ai.dragonfly.math.*
import ai.dragonfly.math.Random.*
import ai.dragonfly.math.geometry.Line
import ai.dragonfly.math.vector.*
import narr.*

import scala.collection.mutable

object CLImg {

  val brailleBytes:NArray[String] = NArray[String](
    //"‚†à",
    "‚†Ä", "‚†Å", "‚†Ç", "‚†É", "‚†Ñ", "‚†Ö", "‚†Ü", "‚†á", "‚°Ä", "‚°Å", "‚°Ç", "‚°É", "‚°Ñ", "‚°Ö", "‚°Ü", "‚°á", "‚†à", "‚†â", "‚†ä", "‚†ã", "‚†å", "‚†ç", "‚†é", "‚†è", "‚°à", "‚°â", "‚°ä", "‚°ã", "‚°å", "‚°ç", "‚°é", "‚°è", "‚†ê", "‚†ë", "‚†í", "‚†ì", "‚†î", "‚†ï", "‚†ñ", "‚†ó", "‚°ê", "‚°ë", "‚°í", "‚°ì", "‚°î", "‚°ï", "‚°ñ", "‚°ó", "‚†ò", "‚†ô", "‚†ö", "‚†õ", "‚†ú", "‚†ù", "‚†û", "‚†ü", "‚°ò", "‚°ô", "‚°ö", "‚°õ", "‚°ú", "‚°ù", "‚°û", "‚°ü", "‚††", "‚†°", "‚†¢", "‚†£", "‚†§", "‚†•", "‚†¶", "‚†ß", "‚°†", "‚°°", "‚°¢", "‚°£", "‚°§", "‚°•", "‚°¶", "‚°ß", "‚†®", "‚†©", "‚†™", "‚†´", "‚†¨", "‚†≠", "‚†Æ", "‚†Ø", "‚°®", "‚°©", "‚°™", "‚°´", "‚°¨", "‚°≠", "‚°Æ", "‚°Ø", "‚†∞", "‚†±", "‚†≤", "‚†≥", "‚†¥", "‚†µ", "‚†∂", "‚†∑", "‚°∞", "‚°±", "‚°≤", "‚°≥", "‚°¥", "‚°µ", "‚°∂", "‚°∑", "‚†∏", "‚†π", "‚†∫", "‚†ª", "‚†º", "‚†Ω", "‚†æ", "‚†ø", "‚°∏", "‚°π", "‚°∫", "‚°ª", "‚°º", "‚°Ω", "‚°æ", "‚°ø", "‚¢Ä", "‚¢Å", "‚¢Ç", "‚¢É", "‚¢Ñ", "‚¢Ö", "‚¢Ü", "‚¢á", "‚£Ä", "‚£Å", "‚£Ç", "‚£É", "‚£Ñ", "‚£Ö", "‚£Ü", "‚£á", "‚¢à", "‚¢â", "‚¢ä", "‚¢ã", "‚¢å", "‚¢ç", "‚¢é", "‚¢è", "‚£à", "‚£â", "‚£ä", "‚£ã", "‚£å", "‚£ç", "‚£é", "‚£è", "‚¢ê", "‚¢ë", "‚¢í", "‚¢ì", "‚¢î", "‚¢ï", "‚¢ñ", "‚¢ó", "‚£ê", "‚£ë", "‚£í", "‚£ì", "‚£î", "‚£ï", "‚£ñ", "‚£ó", "‚¢ò", "‚¢ô", "‚¢ö", "‚¢õ", "‚¢ú", "‚¢ù", "‚¢û", "‚¢ü", "‚£ò", "‚£ô", "‚£ö", "‚£õ", "‚£ú", "‚£ù", "‚£û", "‚£ü", "‚¢†", "‚¢†", "‚¢¢", "‚¢£", "‚¢§", "‚¢•", "‚¢¶", "‚¢ß", "‚£†", "‚£°", "‚£¢", "‚££", "‚£§", "‚£•", "‚£¶", "‚£ß", "‚¢®", "‚¢©", "‚¢™", "‚¢´", "‚¢¨", "‚¢≠", "‚¢Æ", "‚¢Ø", "‚£®", "‚£©", "‚£™", "‚£´", "‚£¨", "‚£≠", "‚£Æ", "‚£Ø", "‚¢∞", "‚¢±", "‚¢≤", "‚¢≥", "‚¢¥", "‚¢µ", "‚¢∂", "‚¢∑", "‚£∞", "‚£±", "‚£≤", "‚£≥", "‚£¥", "‚£µ", "‚£∂", "‚£∑", "‚¢∏", "‚¢π", "‚¢∫", "‚¢ª", "‚¢º", "‚¢Ω", "‚¢æ", "‚¢ø", "‚£∏", "‚£π", "‚£∫", "‚£ª", "‚£º", "‚£Ω", "‚£æ", "‚£ø",
  )

  // Red + Green = Yellow
  // Red + Blue = Magenta
  // Green + Blue = Cyan
  // Red + Green + Blue = White

  val ALL:Int = -1

  val BLACK:Int = 0     // 0000
  val RED:Int = 1       // 0001
  val GREEN:Int = 2     // 0010
  val YELLOW:Int = 3    // 0011
  val BLUE:Int = 4      // 0100
  val MAGENTA:Int = 5   // 0101
  val CYAN:Int = 6      // 0110
  val WHITE:Int = 7     // 0111

  val colorBytes:NArray[String] = NArray[String](
    Console.BLACK,
    Console.RED,
    Console.GREEN,
    Console.YELLOW,
    Console.BLUE,
    Console.MAGENTA,
    Console.CYAN,
    //Console.RESET, // white on dark terminals, black on light ones.
    Console.WHITE  // White is actually gray.
  )

}

class CLImg(val width:Int, val height:Int) {

  import Console.{BOLD, RESET}
  import CLImg.*

  private val w:Int = width >> 1   // width / 2
  private val h:Int = height >> 2  // height / 4

  val pixelCount:Int = w * (h + 1)

  inline def linearIndexOf(x: Int, y: Int): Int = {
    var out = -1
    if (x > -1) {  // && y > -1  // left out y positive check because negative y will always cause negative output
      val x0 = x >> 1
      if (x0 < w) {
        val y0 = y >> 2
        if (y0 < h ) out = x0 + (y0 * w)
      }
    }
    out
  }

  val blackChannel:NArray[Int] = NArray.fill(pixelCount)(0)
  val redChannel:NArray[Int] = NArray.fill(pixelCount)(0)
  val greenChannel:NArray[Int] = NArray.fill(pixelCount)(0)
  val blueChannel:NArray[Int] = NArray.fill(pixelCount)(0)

  val layer:NArray[List[Int]] = NArray.fill(pixelCount)(List[Int]())

  inline def hasRed(color:Int):Boolean = color match {
    case RED => true
    case YELLOW => true
    case MAGENTA => true
    case WHITE => true
    case _ => false
  }

  inline def hasGreen(color:Int):Boolean = color match {
    case GREEN => true
    case YELLOW => true
    case CYAN => true
    case WHITE => true
    case _ => false
  }

  inline def hasBlue(color:Int):Boolean = color match {
    case BLUE => true
    case MAGENTA => true
    case CYAN => true
    case WHITE => true
    case _ => false
  }

  inline private def getColor(i:Int):Int = {
    var out = (if (redChannel(i) > 0) RED else BLACK) | (if (greenChannel(i) > 0) GREEN else BLACK) | (if (blueChannel(i) > 0) BLUE else BLACK)

    if (out != WHITE && layer(i).nonEmpty) {
      var gg:Boolean = false
      for (g <- layer(i)) {
        if (g != WHITE) out = out | g
        else gg = true
      }
      if (gg && out == BLACK) {
        out = WHITE
      }
    }

    out
  }

  def setPixel(x:Int, y:Int, color:Int):CLImg = {
    val i:Int = linearIndexOf(x, y)
    if (i > -1) {
      val pi:Int = (1 << (y % 4)) << (x % 2 * 4)
      color match {
        case BLACK => blackChannel(i) = blackChannel(i) | pi
        case _ =>
          if (hasRed(color)) redChannel(i) = redChannel(i) | pi
          if (hasGreen(color)) greenChannel(i) = greenChannel(i) | pi
          if (hasBlue(color)) blueChannel(i) = blueChannel(i) | pi
      }
      // erasing? (if (color == K) pixels(i) & ~byte else pixels(i) | byte)
    }
    this
  }

  def getPixelColor(x:Int, y:Int):Int = {

    val i:Int = linearIndexOf(x, y)
    if (i > -1) {
      val pi:Int = (1 << (y % 4)) << (x % 2 * 4)

      val out:Int = ( if (  (redChannel(i) ^ pi) > 0 ) 1 else 0 ) |
                    ( if ((greenChannel(i) ^ pi) > 0 ) 2 else 0 ) |
                    ( if ( (blueChannel(i) ^ pi) > 0 ) 4 else 0 )

      if (out == BLACK) {
        if ((blackChannel(i) ^ pi) > 0) BLACK
        else -1
      } else out
    } else -1

  }

  def setGlyph(x:Int, y:Int, color:Int):CLImg = {
    val i:Int = linearIndexOf(x, y)
    if (i > -1) layer(i) = color :: layer(i)
    this
  }

  def channels:NArray[NArray[String]] = NArray.tabulate(colorBytes.length)((channel:Int) => lines(channel) )

  def getPixelBytes(i:Int, channel:Int = ALL):Int = channel match {
    case ALL => redChannel(i) | greenChannel(i) | blueChannel(i) | blackChannel(i)
    case BLACK => blackChannel(i)
    case RED => redChannel(i)
    case GREEN => greenChannel(i)
    case YELLOW => redChannel(i) & greenChannel(i)
    case BLUE => blueChannel(i)
    case MAGENTA => redChannel(i) & blueChannel(i)
    case CYAN => greenChannel(i) & blueChannel(i)
    case WHITE => redChannel(i) & greenChannel(i) & blueChannel(i)
  }

  def lines(channel:Int = ALL):NArray[String] = {
    val out:NArray[String] = NArray.ofSize[String](h)
    var y:Int = 0
    while (y < h) {
      var lastColor:Int = -1
      val ss:SegmentedString = new SegmentedString()

      var x:Int = 0
      while (x < w) {

        val i:Int = (y * w) + x

        val pixelBytes = getPixelBytes(i, channel)
        val color:Int = if (channel == ALL) getColor(i) else channel

        val pattern = pixelBytes & 0x000000ff

        if (color != lastColor || color < 0) {
          lastColor = color
          ss.append(colorBytes(color))
          ss.append(brailleBytes(pattern))
        } else {
          ss.append(brailleBytes(pattern))
        }

        for (g <- layer(i)) {
          ss.append(g.toString)
        }
        x = x + 1
      }
      out(y) = ss.toString()
      y = y + 1
    }
    out
  }

  override def toString:String = {
    val ss:SegmentedString = new SegmentedString()
    val ls:NArray[String] = lines()
    for (line <- ls) {
      ss.append(line).append("\n")
    }
    ss.append(s"${Console.RESET}")
    ss.toString()
  }
}

/* Unicode Braille Characters for Plotting:

‚†Ä
ùÑõ‚†à‚†ê‚†ò‚††‚†®‚†∞‚†∏‚¢Ä‚¢à‚¢ê‚¢ò‚¢†‚¢®‚¢∞‚¢∏
‚†Å‚†â‚†ë‚†ô‚†°‚†©‚†±‚†π‚¢Å‚¢â‚¢ë‚¢ô‚¢†‚¢©‚¢±‚¢π
‚†Ç‚†ä‚†í‚†ö‚†¢‚†™‚†≤‚†∫‚¢Ç‚¢ä‚¢í‚¢ö‚¢¢‚¢™‚¢≤‚¢∫
‚†É‚†ã‚†ì‚†õ‚†£‚†´‚†≥‚†ª‚¢É‚¢ã‚¢ì‚¢õ‚¢£‚¢´‚¢≥‚¢ª
‚†Ñ‚†å‚†î‚†ú‚†§‚†¨‚†¥‚†º‚¢Ñ‚¢å‚¢î‚¢ú‚¢§‚¢¨‚¢¥‚¢º
‚†Ö‚†ç‚†ï‚†ù‚†•‚†≠‚†µ‚†Ω‚¢Ö‚¢ç‚¢ï‚¢ù‚¢•‚¢≠‚¢µ‚¢Ω
‚†Ü‚†é‚†ñ‚†û‚†¶‚†Æ‚†∂‚†æ‚¢Ü‚¢é‚¢ñ‚¢û‚¢¶‚¢Æ‚¢∂‚¢æ
‚†á‚†è‚†ó‚†ü‚†ß‚†Ø‚†∑‚†ø‚¢á‚¢è‚¢ó‚¢ü‚¢ß‚¢Ø‚¢∑‚¢ø
‚°Ä‚°à‚°ê‚°ò‚°†‚°®‚°∞‚°∏‚£Ä‚£à‚£ê‚£ò‚£†‚£®‚£∞‚£∏
‚°Å‚°â‚°ë‚°ô‚°°‚°©‚°±‚°π‚£Å‚£â‚£ë‚£ô‚£°‚£©‚£±‚£π
‚°Ç‚°ä‚°í‚°ö‚°¢‚°™‚°≤‚°∫‚£Ç‚£ä‚£í‚£ö‚£¢‚£™‚£≤‚£∫
‚°É‚°ã‚°ì‚°õ‚°£‚°´‚°≥‚°ª‚£É‚£ã‚£ì‚£õ‚££‚£´‚£≥‚£ª
‚°Ñ‚°å‚°î‚°ú‚°§‚°¨‚°¥‚°º‚£Ñ‚£å‚£î‚£ú‚£§‚£¨‚£¥‚£º
‚°Ö‚°ç‚°ï‚°ù‚°•‚°≠‚°µ‚°Ω‚£Ö‚£ç‚£ï‚£ù‚£•‚£≠‚£µ‚£Ω
‚°Ü‚°é‚°ñ‚°û‚°¶‚°Æ‚°∂‚°æ‚£Ü‚£é‚£ñ‚£û‚£¶‚£Æ‚£∂‚£æ
‚°á‚°è‚°ó‚°ü‚°ß‚°Ø‚°∑‚°ø‚£á‚£è‚£ó‚£ü‚£ß‚£Ø‚£∑‚£ø

‚†ÅÃá ‚†à‚†Ç‚†ê·õ´¬∑ùÜ∫ùÜπ‚†Ñ‚††.‚°Ä‚¢ÄÃ£ [ ‚Éò][Ãä ][‚†ÄÕ¶]

‚††
‚†∞
‚¢∞or‚†∏
‚¢∏
‚ñï
‚ñï¬∑
‚ñï‚†Ü
‚ñï‚†áor‚°Ü
‚ñï‚°á
‚ñï‚ñç
‚£øÔ∏≤‚£øÃ£Ãá
‚£øÔø§‚£ø
‚£øÔ∏∞‚£ø
‚£øÔ∏ô‚£ø
‚£ø‚¶ô‚£ø
‚Éõ‚£ø‚ñï‚£ø
‚£ø‚ñê‚£ø
‚£ø‚ãÆ‚£ø
‚£ø‚Åù‚£ø
‚£ø‚Åû‚£ø
‚£ø:‚£ø
‚£ø¬¶‚£ø
‚£ø‚îÜ‚£ø
‚£ø‚îä‚£ø
‚£ø‚ïé‚£ø
‚£ø‚ïè‚£ø
‚£ø‚îã‚£ø
‚£ø‚Åû‚£ø
‚£ø‚îÜ‚£ø‚Éì
‚£ø‚îä‚£ø
‚£ø‚Äñ‚£ø
‚¶Ä ‚¶ô
‚£ø¬∑‚£ø:‚£øÔ∏ô‚£ø‚àµ‚£ø‚à¥‚£ø‚Éû
‚¢∏‚¶ô¬∑‚¢∏:‚¢∏Ô∏ô‚¢∏‚àµ‚¢∏‚à¥‚¢∏
‚¢∏‚¶ô‚°á¬∑‚°á:‚°áÔ∏ôÃ£·õ¨Ô∏ô‚°á‚àµ‚°á‚à¥‚°á
¬∑ :  ‚àµ Ã£‚à¥
Ô∏∞ Ô∏ô Ãá·õ¨Ã£·õ¨
‚ãÆ ‚Åù ‚Åû ‚óå
Ô∏≤ ‚Åñ ‚Åò ‚Åô ‚Åõ
‚Ä¶ ‚Ä¶‚Éõ ‚¶ô‚¶ô‚¶ô‚É®‚¶ô‚É®‚Éú‚Éí [‚¶ô‚¶ô‚¶ô‚É®‚¶ô]‚Éí
‚ãÆ‚¶ô‚Éõ‚É®


ÃáÃáÃáÃá

 ‚Åñ ‚Åò ‚Åô ‚Åõ
‚óå

üÅ¢üÇ† üÄÜ üÄ´ üÄï üÄò üÄû üÄ† üÄ°
ùÑñ ùÑó ùÑò ùÑô ùÑö ùÑõ

‚öä‚öãùåÄ

‚öå‚öç‚öé
‚öèùåÅùåÇ
ùåÉùåÑùåÖ

‚ò∞ ‚ò± ‚ò≤ ‚ò≥
‚ò¥ ‚òµ ‚ò∂ ‚ò∑

‰∑Ä‰∑Å‰∑Ç‰∑É‰∑Ñ‰∑Ö‰∑Ü‰∑á
‰∑à‰∑â‰∑ä‰∑ã‰∑å‰∑ç‰∑é‰∑è
‰∑ê‰∑ë‰∑í‰∑ì‰∑î‰∑ï‰∑ñ‰∑ó
‰∑ò‰∑ô‰∑ö‰∑õ‰∑ú‰∑ù‰∑û‰∑ü
‰∑†‰∑°‰∑¢‰∑£‰∑§‰∑•‰∑¶‰∑ß
‰∑®‰∑©‰∑™‰∑´‰∑¨‰∑≠‰∑Æ‰∑Ø
‰∑∞‰∑±‰∑≤‰∑≥‰∑¥‰∑µ‰∑∂‰∑∑
‰∑∏‰∑π‰∑∫‰∑ª‰∑º‰∑Ω‰∑æ‰∑ø

ùåÜùåáùåàùåâùåäùåãùååùåçùåéùåèùåêùåëùåíùåìùåîùåïùåñùåóùåòùåô
ùåöùåõùåúùåùùåûùåüùå†ùå°ùå¢ùå£ùå§ùå•ùå¶ùåßùå®ùå©ùå™ùå´ùå¨ùå≠
ùåÆùåØùå∞ùå±ùå≤ùå≥ùå¥ùåµùå∂ùå∑ùå∏ùåπùå∫ùåªùåºùåΩùåæùåøùçÄùçÅ
ùçÇùçÉùçÑùçÖùçÜùçáùçàùçâùçäùçãùçåùççùçéùçèùçêùçëùçíùçìùçîùçïùçñ

‚ñë ‚ñí ‚ñì ‚ñà
‚óå
 ‚Éò
 ‚Éô
 ‚Éö
‚¶ø ‚óâ ‚¶æ ‚óå ‚óé ‚òâ ‚Éù ‚Ä¢ ‚ó¶ ùáá ùáà ‚Ä¢‚É¢  ‚ó¶‚É¢  ‚Ä¢‚É£  ‚ó¶‚É£
‚òÄ ‚òº ‚öπ ‚äï
‚òæ‚òΩ üåë üåí üåì üåî üåï üåñ üåó üåò
 Ãá Ã£ ·õ´
‚Ä¢Ã£¬∑ ÃáÃ£‚Ä¢

 ÃáÃ£   ‚Éò

‚ñ§ ‚ñ• ‚ñ¶ ‚ñß ‚ñ® ‚ñ©
‚öÑ
xÃ£
‚¶æ
*/


// code that generated the braille to bytes relationship.

//  val braille:immutable.TreeMap[Int, String] = immutable.TreeMap[Int, String](
//    0 -> "‚†Ä", 0 + (1 << 4) -> "‚†à", 0 + (2 << 4) -> "‚†ê", 0 + (3 << 4) -> "‚†ò", 0 + (4 << 4) -> "‚††", 0 + (5 << 4) -> "‚†®", 0 + (6 << 4) -> "‚†∞", 0 + (7 << 4) -> "‚†∏", 0 + (8 << 4) -> "‚¢Ä", 0 + (9 << 4) -> "‚¢à", 0 + (10 << 4) -> "‚¢ê", 0 + (11 << 4) -> "‚¢ò", 0 + (12 << 4) -> "‚¢†", 0 + (13 << 4) -> "‚¢®", 0 + (14 << 4) -> "‚¢∞", 0 + (15 << 4) -> "‚¢∏",
//    1 -> "‚†Å", 1 + (1 << 4) -> "‚†â", 1 + (2 << 4) -> "‚†ë", 1 + (3 << 4) -> "‚†ô", 1 + (4 << 4) -> "‚†°", 1 + (5 << 4) -> "‚†©", 1 + (6 << 4) -> "‚†±", 1 + (7 << 4) -> "‚†π", 1 + (8 << 4) -> "‚¢Å", 1 + (9 << 4) -> "‚¢â", 1 + (10 << 4) -> "‚¢ë", 1 + (11 << 4) -> "‚¢ô", 1 + (12 << 4) -> "‚¢†", 1 + (13 << 4) -> "‚¢©", 1 + (14 << 4) -> "‚¢±", 1 + (15 << 4) -> "‚¢π",
//    2 -> "‚†Ç", 2 + (1 << 4) -> "‚†ä", 2 + (2 << 4) -> "‚†í", 2 + (3 << 4) -> "‚†ö", 2 + (4 << 4) -> "‚†¢", 2 + (5 << 4) -> "‚†™", 2 + (6 << 4) -> "‚†≤", 2 + (7 << 4) -> "‚†∫", 2 + (8 << 4) -> "‚¢Ç", 2 + (9 << 4) -> "‚¢ä", 2 + (10 << 4) -> "‚¢í", 2 + (11 << 4) -> "‚¢ö", 2 + (12 << 4) -> "‚¢¢", 2 + (13 << 4) -> "‚¢™", 2 + (14 << 4) -> "‚¢≤", 2 + (15 << 4) -> "‚¢∫",
//    3 -> "‚†É", 3 + (1 << 4) -> "‚†ã", 3 + (2 << 4) -> "‚†ì", 3 + (3 << 4) -> "‚†õ", 3 + (4 << 4) -> "‚†£", 3 + (5 << 4) -> "‚†´", 3 + (6 << 4) -> "‚†≥", 3 + (7 << 4) -> "‚†ª", 3 + (8 << 4) -> "‚¢É", 3 + (9 << 4) -> "‚¢ã", 3 + (10 << 4) -> "‚¢ì", 3 + (11 << 4) -> "‚¢õ", 3 + (12 << 4) -> "‚¢£", 3 + (13 << 4) -> "‚¢´", 3 + (14 << 4) -> "‚¢≥", 3 + (15 << 4) -> "‚¢ª",
//    4 -> "‚†Ñ", 4 + (1 << 4) -> "‚†å", 4 + (2 << 4) -> "‚†î", 4 + (3 << 4) -> "‚†ú", 4 + (4 << 4) -> "‚†§", 4 + (5 << 4) -> "‚†¨", 4 + (6 << 4) -> "‚†¥", 4 + (7 << 4) -> "‚†º", 4 + (8 << 4) -> "‚¢Ñ", 4 + (9 << 4) -> "‚¢å", 4 + (10 << 4) -> "‚¢î", 4 + (11 << 4) -> "‚¢ú", 4 + (12 << 4) -> "‚¢§", 4 + (13 << 4) -> "‚¢¨", 4 + (14 << 4) -> "‚¢¥", 4 + (15 << 4) -> "‚¢º",
//    5 -> "‚†Ö", 5 + (1 << 4) -> "‚†ç", 5 + (2 << 4) -> "‚†ï", 5 + (3 << 4) -> "‚†ù", 5 + (4 << 4) -> "‚†•", 5 + (5 << 4) -> "‚†≠", 5 + (6 << 4) -> "‚†µ", 5 + (7 << 4) -> "‚†Ω", 5 + (8 << 4) -> "‚¢Ö", 5 + (9 << 4) -> "‚¢ç", 5 + (10 << 4) -> "‚¢ï", 5 + (11 << 4) -> "‚¢ù", 5 + (12 << 4) -> "‚¢•", 5 + (13 << 4) -> "‚¢≠", 5 + (14 << 4) -> "‚¢µ", 5 + (15 << 4) -> "‚¢Ω",
//    6 -> "‚†Ü", 6 + (1 << 4) -> "‚†é", 6 + (2 << 4) -> "‚†ñ", 6 + (3 << 4) -> "‚†û", 6 + (4 << 4) -> "‚†¶", 6 + (5 << 4) -> "‚†Æ", 6 + (6 << 4) -> "‚†∂", 6 + (7 << 4) -> "‚†æ", 6 + (8 << 4) -> "‚¢Ü", 6 + (9 << 4) -> "‚¢é", 6 + (10 << 4) -> "‚¢ñ", 6 + (11 << 4) -> "‚¢û", 6 + (12 << 4) -> "‚¢¶", 6 + (13 << 4) -> "‚¢Æ", 6 + (14 << 4) -> "‚¢∂", 6 + (15 << 4) -> "‚¢æ",
//    7 -> "‚†á", 7 + (1 << 4) -> "‚†è", 7 + (2 << 4) -> "‚†ó", 7 + (3 << 4) -> "‚†ü", 7 + (4 << 4) -> "‚†ß", 7 + (5 << 4) -> "‚†Ø", 7 + (6 << 4) -> "‚†∑", 7 + (7 << 4) -> "‚†ø", 7 + (8 << 4) -> "‚¢á", 7 + (9 << 4) -> "‚¢è", 7 + (10 << 4) -> "‚¢ó", 7 + (11 << 4) -> "‚¢ü", 7 + (12 << 4) -> "‚¢ß", 7 + (13 << 4) -> "‚¢Ø", 7 + (14 << 4) -> "‚¢∑", 7 + (15 << 4) -> "‚¢ø",
//    8 -> "‚°Ä", 8 + (1 << 4) -> "‚°à", 8 + (2 << 4) -> "‚°ê", 8 + (3 << 4) -> "‚°ò", 8 + (4 << 4) -> "‚°†", 8 + (5 << 4) -> "‚°®", 8 + (6 << 4) -> "‚°∞", 8 + (7 << 4) -> "‚°∏", 8 + (8 << 4) -> "‚£Ä", 8 + (9 << 4) -> "‚£à", 8 + (10 << 4) -> "‚£ê", 8 + (11 << 4) -> "‚£ò", 8 + (12 << 4) -> "‚£†", 8 + (13 << 4) -> "‚£®", 8 + (14 << 4) -> "‚£∞", 8 + (15 << 4) -> "‚£∏",
//    9 -> "‚°Å", 9 + (1 << 4) -> "‚°â", 9 + (2 << 4) -> "‚°ë", 9 + (3 << 4) -> "‚°ô", 9 + (4 << 4) -> "‚°°", 9 + (5 << 4) -> "‚°©", 9 + (6 << 4) -> "‚°±", 9 + (7 << 4) -> "‚°π", 9 + (8 << 4) -> "‚£Å", 9 + (9 << 4) -> "‚£â", 9 + (10 << 4) -> "‚£ë", 9 + (11 << 4) -> "‚£ô", 9 + (12 << 4) -> "‚£°", 9 + (13 << 4) -> "‚£©", 9 + (14 << 4) -> "‚£±", 9 + (15 << 4) -> "‚£π",
//    10 -> "‚°Ç", 10 + (1 << 4) -> "‚°ä", 10 + (2 << 4) -> "‚°í", 10 + (3 << 4) -> "‚°ö", 10 + (4 << 4) -> "‚°¢", 10 + (5 << 4) -> "‚°™", 10 + (6 << 4) -> "‚°≤", 10 + (7 << 4) -> "‚°∫", 10 + (8 << 4) -> "‚£Ç", 10 + (9 << 4) -> "‚£ä", 10 + (10 << 4) -> "‚£í", 10 + (11 << 4) -> "‚£ö", 10 + (12 << 4) -> "‚£¢", 10 + (13 << 4) -> "‚£™", 10 + (14 << 4) -> "‚£≤", 10 + (15 << 4) -> "‚£∫",
//    11 -> "‚°É", 11 + (1 << 4) -> "‚°ã", 11 + (2 << 4) -> "‚°ì", 11 + (3 << 4) -> "‚°õ", 11 + (4 << 4) -> "‚°£", 11 + (5 << 4) -> "‚°´", 11 + (6 << 4) -> "‚°≥", 11 + (7 << 4) -> "‚°ª", 11 + (8 << 4) -> "‚£É", 11 + (9 << 4) -> "‚£ã", 11 + (10 << 4) -> "‚£ì", 11 + (11 << 4) -> "‚£õ", 11 + (12 << 4) -> "‚££", 11 + (13 << 4) -> "‚£´", 11 + (14 << 4) -> "‚£≥", 11 + (15 << 4) -> "‚£ª",
//    12 -> "‚°Ñ", 12 + (1 << 4) -> "‚°å", 12 + (2 << 4) -> "‚°î", 12 + (3 << 4) -> "‚°ú", 12 + (4 << 4) -> "‚°§", 12 + (5 << 4) -> "‚°¨", 12 + (6 << 4) -> "‚°¥", 12 + (7 << 4) -> "‚°º", 12 + (8 << 4) -> "‚£Ñ", 12 + (9 << 4) -> "‚£å", 12 + (10 << 4) -> "‚£î", 12 + (11 << 4) -> "‚£ú", 12 + (12 << 4) -> "‚£§", 12 + (13 << 4) -> "‚£¨", 12 + (14 << 4) -> "‚£¥", 12 + (15 << 4) -> "‚£º",
//    13 -> "‚°Ö", 13 + (1 << 4) -> "‚°ç", 13 + (2 << 4) -> "‚°ï", 13 + (3 << 4) -> "‚°ù", 13 + (4 << 4) -> "‚°•", 13 + (5 << 4) -> "‚°≠", 13 + (6 << 4) -> "‚°µ", 13 + (7 << 4) -> "‚°Ω", 13 + (8 << 4) -> "‚£Ö", 13 + (9 << 4) -> "‚£ç", 13 + (10 << 4) -> "‚£ï", 13 + (11 << 4) -> "‚£ù", 13 + (12 << 4) -> "‚£•", 13 + (13 << 4) -> "‚£≠", 13 + (14 << 4) -> "‚£µ", 13 + (15 << 4) -> "‚£Ω",
//    14 -> "‚°Ü", 14 + (1 << 4) -> "‚°é", 14 + (2 << 4) -> "‚°ñ", 14 + (3 << 4) -> "‚°û", 14 + (4 << 4) -> "‚°¶", 14 + (5 << 4) -> "‚°Æ", 14 + (6 << 4) -> "‚°∂", 14 + (7 << 4) -> "‚°æ", 14 + (8 << 4) -> "‚£Ü", 14 + (9 << 4) -> "‚£é", 14 + (10 << 4) -> "‚£ñ", 14 + (11 << 4) -> "‚£û", 14 + (12 << 4) -> "‚£¶", 14 + (13 << 4) -> "‚£Æ", 14 + (14 << 4) -> "‚£∂", 14 + (15 << 4) -> "‚£æ",
//    15 -> "‚°á", 15 + (1 << 4) -> "‚°è", 15 + (2 << 4) -> "‚°ó", 15 + (3 << 4) -> "‚°ü", 15 + (4 << 4) -> "‚°ß", 15 + (5 << 4) -> "‚°Ø", 15 + (6 << 4) -> "‚°∑", 15 + (7 << 4) -> "‚°ø", 15 + (8 << 4) -> "‚£á", 15 + (9 << 4) -> "‚£è", 15 + (10 << 4) -> "‚£ó", 15 + (11 << 4) -> "‚£ü", 15 + (12 << 4) -> "‚£ß", 15 + (13 << 4) -> "‚£Ø", 15 + (14 << 4) -> "‚£∑", 15 + (15 << 4) -> "‚£ø"
//  )
//
//  for ((k, v) <- braille) print(s"\"$v\", ")

